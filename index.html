<!DOCTYPE html>
<html>
<head>
    <title>Field Data Dashboard</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Leaflet & MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        #map { height: 100vh; width: 100%; }
        
        .dashboard-panel {
            position: absolute; top: 10px; left: 10px; z-index: 1000;
            background: rgba(255, 255, 255, 0.9); padding: 10px 15px;
            border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            max-width: 280px; border: 1px solid #ddd;
        }
        .dashboard-panel h3 { margin: 0 0 10px 0; }
        .dashboard-stats p { margin: 5px 0; font-size: 14px; }
        .dashboard-stats strong { color: #333; }
        .dashboard-filters h4 { margin: 15px 0 5px 0; font-size: 15px; border-top: 1px solid #eee; padding-top: 10px; }
        .filter-buttons { display: flex; gap: 5px; flex-wrap: wrap; }
        .filter-buttons button {
            flex-grow: 1; padding: 6px 8px; font-size: 12px; border: 1px solid #ccc;
            background-color: #f9f9f9; border-radius: 4px; cursor: pointer; transition: all 0.2s ease;
        }
        .filter-buttons button:hover { background-color: #e9e9e9; border-color: #999; }
        .filter-buttons button.active { background-color: #8A2BE2; color: white; border-color: #8A2BE2; font-weight: bold; }
        #status { font-style: italic; color: #666; font-size: 12px; margin-top: 10px; }

        @media (max-width: 480px) {
            .dashboard-panel { top: 10px; left: 10px; right: 10px; width: auto; max-width: none; }
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div class="dashboard-panel">
        <h3>Dashboard</h3>
        <div class="dashboard-stats">
            <p>Total Points Shown: <strong id="count-total">...</strong></p>
            <p>Today's Points: <strong id="count-today">...</strong></p>
            <p>Last Hour: <strong id="count-hour">...</strong></p>
        </div>
        <div class="dashboard-filters">
            <h4>Filter by Time</h4>
            <div class="filter-buttons">
                <button id="filter-all" class="active">All Time</button>
                <button id="filter-today">Today</button>
                <button id="filter-2days">Last 2 Days</button>
            </div>
        </div>
        <div id="status">Initializing...</div>
    </div>
    
    <!-- Leaflet & MarkerCluster JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <script>
        // --- CONFIGURATION ---
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyZjjPHSKNNGJBJudDzshTc1XASWrMtDALSN5kwNOP7edELrv8eqh_r3hBcdCGgYUrFPQ/exec';
        const REFRESH_INTERVAL_MS = 60000;
        const BASE_DOT_COLOR = '#8A2BE2';
        const NEWEST_DOT_COLOR = '#FF00FF';
        const CLUSTER_DISABLE_ZOOM = 12; // Zoom level to disable clustering
        // --- END CONFIGURATION ---

        // --- GLOBAL STATE ---
        let allGeoJsonData = null; // Master dataset from the server
        let pointsLayer = null;    // The main map layer (MarkerClusterGroup)
        let countiesLayer = null;
        let activeFilter = 'all';  // Current filter state

        const map = L.map('map', { center: [40.0, -96.0], zoom: 4 });
        const layersControl = L.control.layers(null, null, { position: 'bottomright' }).addTo(map);
        
        const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OpenStreetMap, © CARTO' }).addTo(map);
        layersControl.addBaseLayer(cartoLight, "Light (Carto)");
        
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri' });
        layersControl.addBaseLayer(satellite, "Satellite");
        
        const statusDiv = document.getElementById('status');

        // --- HELPER FUNCTIONS ---
        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        function lerpColor(a, b, amount) { 
            const ar = a >> 16, ag = a >> 8 & 0xff, ab = a & 0xff, br = b >> 16, bg = b >> 8 & 0xff, bb = b & 0xff,
                  rr = ar + amount * (br - ar), rg = ag + amount * (bg - ag), rb = ab + amount * (bb - ab);
            return "#" + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
        }

        // --- DATA FETCHING & PROCESSING ---
        async function fetchData() {
            let isInitialLoad = !allGeoJsonData;
            statusDiv.textContent = 'Fetching new data...';
            try {
                const response = await fetch(WEB_APP_URL + '?t=' + Date.now());
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (!data.features) { throw new Error("Data response is missing 'features' array."); }

                // The reliable date parsing pipeline
                data.features.forEach(feature => {
                    feature.properties.dateObject = new Date(feature.properties.timestamp);
                });
                data.features.sort((a, b) => a.properties.dateObject - b.properties.dateObject);
                allGeoJsonData = data; // Update the master dataset
                
                // Update the UI
                updateDashboardStats();
                updateMap(); 

                if (isInitialLoad && allGeoJsonData.features.length > 0) {
                    // Fit map bounds only on the very first successful load
                    map.fitBounds(pointsLayer.getBounds().pad(0.1));
                }
                statusDiv.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
            } catch (error) {
                console.error('Failed to fetch or process data:', error);
                statusDiv.textContent = 'Error loading data. Check console.';
            }
        }
        
        // --- UI & DASHBOARD UPDATES ---
        function updateDashboardStats() {
            if (!allGeoJsonData) return;
            
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - (60 * 60 * 1000));
            const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            let todayCount = 0;
            let hourCount = 0;

            allGeoJsonData.features.forEach(feature => {
                const d = feature.properties.dateObject;
                if (d && !isNaN(d)) {
                    if (d >= startOfToday) todayCount++;
                    if (d >= oneHourAgo) hourCount++;
                }
            });
            
            document.getElementById('count-today').textContent = todayCount;
            document.getElementById('count-hour').textContent = hourCount;
        }

        // --- MAP RENDERING LOGIC ---
        function updateMap() {
            if (!allGeoJsonData) return;

            // 1. Filter the master data based on the active filter
            const now = new Date();
            const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const twoDaysAgo = new Date(now.getTime() - (2 * 24 * 60 * 60 * 1000));

            const filteredFeatures = allGeoJsonData.features.filter(feature => {
                const d = feature.properties.dateObject;
                if (!d || isNaN(d)) return false; // Exclude invalid dates
                switch (activeFilter) {
                    case 'today': return d >= startOfToday;
                    case '2days': return d >= twoDaysAgo;
                    case 'all': default: return true;
                }
            });
            document.getElementById('count-total').textContent = filteredFeatures.length;
            
            // 2. Clear the old layer
            if (pointsLayer) { map.removeLayer(pointsLayer); }

            // 3. Create the MarkerClusterGroup for smart rendering
            pointsLayer = L.markerClusterGroup({
                disableClusteringAtZoom: CLUSTER_DISABLE_ZOOM,
                chunkedLoading: true
            });
            
            // 4. Create the GeoJSON layer with custom styling
            const minTime = filteredFeatures.length > 0 ? filteredFeatures[0].properties.dateObject.getTime() : 0;
            const maxTime = filteredFeatures.length > 0 ? filteredFeatures[filteredFeatures.length - 1].properties.dateObject.getTime() : 0;

            const geoJsonLayer = L.geoJSON({ type: "FeatureCollection", features: filteredFeatures }, {
                pointToLayer: (feature, latlng) => {
                    let color = BASE_DOT_COLOR;
                    const timeSpan = maxTime - minTime;
                    if (timeSpan > 0) {
                        const ageRatio = (feature.properties.dateObject.getTime() - minTime) / timeSpan;
                        const baseHex = parseInt(BASE_DOT_COLOR.slice(1), 16);
                        const newHex = parseInt(NEWEST_DOT_COLOR.slice(1), 16);
                        color = lerpColor(baseHex, newHex, ageRatio);
                    }
                    return L.circleMarker(latlng, {
                        radius: 6, stroke: false, fillColor: color, fillOpacity: 0.9
                    });
                },
                onEachFeature: (feature, layer) => {
                    const readableDate = feature.properties.dateObject.toLocaleString();
                    layer.bindPopup(`<b>Timestamp:</b> ${readableDate}`);
                }
            });
            
            pointsLayer.addLayer(geoJsonLayer);
            map.addLayer(pointsLayer);
        }

        async function loadCountyBoundaries() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
                const countiesData = await response.json();
                countiesLayer = L.geoJSON(countiesData, {
                    style: { color: "#888", weight: 1, opacity: 0.65, fillOpacity: 0 },
                    interactive: false
                }).addTo(map);
                layersControl.addOverlay(countiesLayer, 'US Counties');
            } catch (error) { console.error('Could not load county boundaries:', error); }
        }

        // --- EVENT LISTENERS FOR FILTERS ---
        const filterButtons = document.querySelectorAll('.filter-buttons button');
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                filterButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                activeFilter = button.id.split('-')[1]; // e.g., 'filter-today' -> 'today'
                updateMap(); // Re-render the map with the new filter
            });
        });

        // --- START THE APPLICATION ---
        fetchData();
        setInterval(fetchData, REFRESH_INTERVAL_MS);
        loadCountyBoundaries();
    </script>
</body>
</html>
