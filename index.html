<!DOCTYPE html>
<html>
<head>
    <title>Field Data Monitor</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; }
        #map { height: 100vh; width: 100%; }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <strong>Live Field Map</strong>
        <div id="status">Loading data...</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyZjjPHSKNNGJBJudDzshTc1XASWrMtDALSN5kwNOP7edELrv8eqh_r3hBcdCGgYUrFPQ/exec'; // Paste your URL here
        const REFRESH_INTERVAL_MS = 30000;
        const dotColor = '#a855f7'; // purple
        // --- END CONFIGURATION ---

        // Render with Canvas for smoother performance
        const canvasRenderer = L.canvas({ padding: 0.5 });

        // Basemaps (default: Light)
        const plainWhite = L.gridLayer({ attribution: '' });
        plainWhite.createTile = function(coords) {
            const tile = document.createElement('canvas');
            tile.width = 256; tile.height = 256;
            const ctx = tile.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 256, 256);
            return tile;
        };

        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19, attribution: '© OpenStreetMap contributors'
        });

        const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, attribution: '© OpenStreetMap, © CARTO'
        });

        const dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, attribution: '© OpenStreetMap, © CARTO'
        });

        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles © Esri — Sources: Esri, USGS, USDA, etc.'
        });

        const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 17, attribution: '© OpenTopoMap (CC-BY-SA), © OpenStreetMap'
        });

        // Map (default to Light)
        const map = L.map('map', {
            center: [40.0, -96.0],
            zoom: 4,
            preferCanvas: true,
            renderer: canvasRenderer,
            layers: [cartoLight]
        });

        // Basemap switcher at bottom-right
        const baseMaps = {
            "Light (Carto)": cartoLight,
            "Street (OSM)": osm,
            "Plain White": plainWhite,
            "Dark (Carto)": dark,
            "Satellite (Esri)": satellite,
            "Topo (OpenTopoMap)": topo
        };
        const layersControl = L.control.layers(baseMaps, null, { position: 'bottomright' }).addTo(map);

        let pointsLayer = null;
        const statusDiv = document.getElementById('status');

        // Smooth, borderless purple dots
        function pointToDot(feature, latlng) {
            return L.circleMarker(latlng, {
                renderer: canvasRenderer,
                radius: 6,
                stroke: false,        // no border
                fillColor: dotColor,  // purple
                fillOpacity: 0.9
            });
        }

        async function fetchData() {
            try {
                statusDiv.textContent = 'Fetching new data...';
                const response = await fetch(WEB_APP_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (pointsLayer) {
                    map.removeLayer(pointsLayer);
                }

                pointsLayer = L.geoJSON(data, {
                    pointToLayer: pointToDot,
                    onEachFeature: function (feature, layer) {
                        const props = feature.properties;
                        layer.bindPopup(`<b>Timestamp:</b> ${props.timestamp}`);
                    }
                }).addTo(map);

                // Fit once on first load if you're at the starting zoom
                if (map.getZoom() <= 4 && data.features.length > 0) {
                    map.fitBounds(pointsLayer.getBounds().pad(0.1));
                }

                statusDiv.textContent = `Updated: ${new Date().toLocaleTimeString()} (${data.features.length} points)`;
            } catch (error) {
                console.error('Failed to fetch map data:', error);
                statusDiv.textContent = 'Error loading data.';
            }
        }

        // Optional: US county boundaries overlay (toggleable)
        let countiesLayer;
        async function loadCountyBoundaries() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
                const countiesData = await response.json();

                countiesLayer = L.geoJSON(countiesData, {
                    style: { color: "#888", weight: 1, opacity: 0.65, fillOpacity: 0 },
                    interactive: false
                }).addTo(map);

                layersControl.addOverlay(countiesLayer, 'US Counties');
            } catch (error) {
                console.error('Could not load county boundaries:', error);
            }
        }

        // Start
        fetchData();
        setInterval(fetchData, REFRESH_INTERVAL_MS);
        loadCountyBoundaries();
    </script>
</body>
</html>
