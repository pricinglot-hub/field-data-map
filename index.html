<!DOCTYPE html>
<html>
<head>
    <title>Field Data Monitor</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
        #map { height: 100vh; width: 100%; }
        .info-panel, .playback-panel {
            position: absolute; z-index: 1000;
            background: white; padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .info-panel { top: 10px; right: 10px; }
        
        .playback-panel {
            bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 10px;
            padding: 8px 12px;
        }
        .playback-panel button {
            font-size: 14px; padding: 5px 10px; border-radius: 5px; border: 1px solid #ccc;
            background-color: #f0f0f0; cursor: pointer;
        }
        .playback-panel button:hover { background-color: #e0e0e0; }
        .playback-panel input[type="range"] {
            width: 250px;
        }
        .playback-panel .time-label {
            font-size: 12px; color: #555; min-width: 140px; text-align: center;
        }
        
        @media (max-width: 600px) {
            .playback-panel {
                flex-wrap: wrap; width: calc(100% - 40px);
                bottom: 10px; left: 10px; transform: none;
            }
            .playback-panel input[type="range"] { width: 100%; order: 1; }
            .playback-panel .time-label { order: 2; width: 100%; text-align: left; margin-top: 5px; }
            .playback-panel .buttons { order: 3; }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <strong>Live Field Map</strong>
        <div id="status">Loading data...</div>
    </div>
    
    <div class="playback-panel" style="display: none;">
        <div class="buttons">
            <button id="playPauseBtn">▶ Play</button>
            <button id="restartBtn">⟲ Restart</button>
        </div>
        <input type="range" id="timeSlider" min="0" max="100" value="0" step="1" />
        <div class="time-label" id="timeLabel">--</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyZjjPHSKNNGJBJudDzshTc1XASWrMtDALSN5kwNOP7edELrv8eqh_r3hBcdCGgYUrFPQ/exec';
        const REFRESH_INTERVAL_MS = 90000;
        const BASE_DOT_COLOR = '#8A2BE2'; 
        const NEWEST_DOT_COLOR = '#FF00FF';
        const ANIMATION_SPEED_MS = 20;
        // --- END CONFIGURATION ---

        const map = L.map('map', { center: [40.0, -96.0], zoom: 4 });
        const layersControl = L.control.layers(null, null, { position: 'bottomright' }).addTo(map);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OpenStreetMap, © CARTO' }).addTo(map);
        
        let allFeatures = [];
        let pointsLayer = null;
        let animationFrameId = null;
        let countiesLayer = null; // --- ADDED: Variable for counties layer ---
        
        const statusDiv = document.getElementById('status');
        const playbackPanel = document.querySelector('.playback-panel');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const timeSlider = document.getElementById('timeSlider');
        const timeLabel = document.getElementById('timeLabel');
        
        async function fetchData() {
            try {
                statusDiv.textContent = 'Fetching new data...';
                const response = await fetch(WEB_APP_URL + '?t=' + Date.now());
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (!data.features || data.features.length === 0) {
                    statusDiv.textContent = 'No features found.'; return;
                }

                data.features.forEach(feature => {
                    feature.properties.dateObject = new Date(feature.properties.timestamp);
                });
                data.features.sort((a, b) => a.properties.dateObject - b.properties.dateObject);
                allFeatures = data.features;
                
                initializePlayback();
                
                if (map.getZoom() <= 4) {
                    const bounds = L.geoJSON(allFeatures).getBounds();
                    if(bounds.isValid()) map.fitBounds(bounds.pad(0.1));
                }
                statusDiv.textContent = `Ready: ${allFeatures.length} points loaded`;
            } catch (error) {
                console.error('Failed to fetch/process data:', error);
                statusDiv.textContent = 'Error loading data.';
            }
        }
        
        function initializePlayback() {
            stopAnimation();
            playbackPanel.style.display = 'flex';
            
            timeSlider.min = 0;
            timeSlider.max = allFeatures.length - 1;
            timeSlider.value = allFeatures.length - 1;

            renderPoints(allFeatures.length);
        }
        
        function renderPoints(count) {
            if (pointsLayer) { map.removeLayer(pointsLayer); }
            
            const visibleFeatures = allFeatures.slice(0, count);
            if (visibleFeatures.length === 0) {
                 timeLabel.textContent = '--';
                 return;
            }
            
            const minTime = allFeatures[0].properties.dateObject.getTime();
            const maxTime = allFeatures[allFeatures.length - 1].properties.dateObject.getTime();
            
            pointsLayer = L.geoJSON(visibleFeatures, {
                pointToLayer: (feature, latlng) => {
                    let color = BASE_DOT_COLOR;
                    const timeSpan = maxTime - minTime;
                    if (timeSpan > 0) {
                        const ageRatio = (feature.properties.dateObject.getTime() - minTime) / timeSpan;
                        const baseHex = parseInt(BASE_DOT_COLOR.slice(1), 16);
                        const newHex = parseInt(NEWEST_DOT_COLOR.slice(1), 16);
                        color = lerpColor(baseHex, newHex, ageRatio);
                    }
                    return L.circleMarker(latlng, {
                        radius: 6, stroke: false, fillColor: color, fillOpacity: 0.9
                    });
                },
                onEachFeature: (feature, layer) => {
                    const readableDate = feature.properties.dateObject.toLocaleString();
                    layer.bindPopup(`<b>Timestamp:</b> ${readableDate}`);
                }
            }).addTo(map);

            const currentFeature = allFeatures[count - 1];
            timeLabel.textContent = currentFeature.properties.dateObject.toLocaleString();
            timeSlider.value = count - 1;
        }

        function playAnimation() {
            playPauseBtn.textContent = '❚❚ Pause';
            // --- FIX: If slider is at the end, restart before playing ---
            let currentIndex = Number(timeSlider.value);
            if (currentIndex >= allFeatures.length - 1) {
                currentIndex = 0;
            }

            function animate() {
                currentIndex++;
                if (currentIndex >= allFeatures.length) {
                    stopAnimation();
                    return;
                }
                renderPoints(currentIndex + 1);
                animationFrameId = setTimeout(animate, ANIMATION_SPEED_MS);
            }
            animate();
        }

        function stopAnimation() {
            if (animationFrameId) {
                clearTimeout(animationFrameId);
                animationFrameId = null;
            }
            playPauseBtn.textContent = '▶ Play';
        }

        playPauseBtn.addEventListener('click', () => {
            if (animationFrameId) { stopAnimation(); } else { playAnimation(); }
        });

        restartBtn.addEventListener('click', () => {
            stopAnimation();
            renderPoints(1);
        });
        
        timeSlider.addEventListener('input', () => {
            stopAnimation();
            const index = Number(timeSlider.value);
            renderPoints(index + 1);
        });
        
        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
        function lerpColor(a, b, amount) { 
            const ar = a >> 16, ag = a >> 8 & 0xff, ab = a & 0xff, br = b >> 16, bg = b >> 8 & 0xff, bb = b & 0xff,
                  rr = ar + amount * (br - ar), rg = ag + amount * (bg - ag), rb = ab + amount * (bb - ab);
            return "#" + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
        }

        // --- ADDED: County boundaries function ---
        async function loadCountyBoundaries() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
                const countiesData = await response.json();
                countiesLayer = L.geoJSON(countiesData, {
                    style: { color: "#888", weight: 1, opacity: 0.65, fillOpacity: 0 },
                    interactive: false
                }).addTo(map);
                // Add to the layer control so it can be toggled
                layersControl.addOverlay(countiesLayer, 'US Counties');
            } catch (error) {
                console.error('Could not load county boundaries:', error);
            }
        }
        
        // --- START ---
        fetchData();
        setInterval(fetchData, REFRESH_INTERVAL_MS);
        loadCountyBoundaries(); // --- ADDED: Call the function on start ---
    </script>
</body>
</html>
