<!DOCTYPE html>
<html>
<head>
    <title>Field Data Monitor</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; }
        #map { height: 100vh; width: 100%; }
        .info-panel {
            position: absolute; top: 10px; right: 10px; z-index: 1000;
            background: white; padding: 10px; border-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <strong>Live Field Map</strong>
        <div id="status">Loading data...</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyZjjPHSKNNGJBJudDzshTc1XASWrMtDALSN5kwNOP7edELrv8eqh_r3hBcdCGgYUrFPQ/exec';
        const REFRESH_INTERVAL_MS = 30000;
        const BASE_DOT_COLOR = '#8A2BE2'; // Base Purple
        const NEWEST_DOT_COLOR = '#FF00FF'; // Highlight Magenta for newest points
        // --- END CONFIGURATION ---

        const map = L.map('map', { center: [40.0, -96.0], zoom: 4 });
        const layersControl = L.control.layers(null, null, { position: 'bottomright' }).addTo(map);
        
        const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, attribution: '© OpenStreetMap, © CARTO'
        }).addTo(map);
        layersControl.addBaseLayer(cartoLight, "Light (Carto)");
        
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles © Esri'
        });
        layersControl.addBaseLayer(satellite, "Satellite");

        let pointsLayer = null;
        let countiesLayer = null;
        const statusDiv = document.getElementById('status');

        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

        function lerpColor(a, b, amount) { 
            const ar = a >> 16, ag = a >> 8 & 0xff, ab = a & 0xff,
                  br = b >> 16, bg = b >> 8 & 0xff, bb = b & 0xff,
                  rr = ar + amount * (br - ar),
                  rg = ag + amount * (bg - ag),
                  rb = ab + amount * (bb - ab);
            return "#" + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);
        }

        async function fetchData() {
            try {
                statusDiv.textContent = 'Fetching new data...';
                const response = await fetch(WEB_APP_URL + '?t=' + Date.now()); // Cache buster
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (!data.features || data.features.length === 0) {
                    statusDiv.textContent = 'No features found in data.';
                    return;
                }

                // --- THIS IS THE KEY ---
                // 1. Parse the reliable ISO date string from the API into a real Date object.
                data.features.forEach(feature => {
                    feature.properties.dateObject = new Date(feature.properties.timestamp);
                });

                // 2. Sort by date to find the oldest and newest for the color gradient.
                data.features.sort((a, b) => a.properties.dateObject - b.properties.dateObject);
                
                const minTime = data.features[0].properties.dateObject.getTime();
                const maxTime = data.features[data.features.length - 1].properties.dateObject.getTime();

                if (pointsLayer) {
                    map.removeLayer(pointsLayer);
                }

                pointsLayer = L.geoJSON(data, {
                    pointToLayer: function (feature, latlng) {
                        // 3. Calculate color based on the feature's date.
                        let color = BASE_DOT_COLOR;
                        const timeSpan = maxTime - minTime;
                        if (timeSpan > 0) {
                            const ageRatio = (feature.properties.dateObject.getTime() - minTime) / timeSpan;
                            const baseHex = parseInt(BASE_DOT_COLOR.slice(1), 16);
                            const newHex = parseInt(NEWEST_DOT_COLOR.slice(1), 16);
                            color = lerpColor(baseHex, newHex, ageRatio);
                        }
                        
                        return L.circleMarker(latlng, {
                            radius: 6, stroke: false, fillColor: color, fillOpacity: 0.9
                        });
                    },
                    onEachFeature: function (feature, layer) {
                        // 4. Display the date in a nice, human-readable format.
                        const readableDate = feature.properties.dateObject.toLocaleString();
                        layer.bindPopup(`<b>Timestamp:</b> ${readableDate}`);
                    }
                }).addTo(map);

                // Fit bounds on the very first successful data load
                if (map.getZoom() <= 4 && data.features.length > 0) {
                    map.fitBounds(pointsLayer.getBounds().pad(0.1));
                }

                statusDiv.textContent = `Updated: ${new Date().toLocaleTimeString()} (${data.features.length} points)`;
            } catch (error) {
                console.error('Failed to fetch or process map data:', error);
                statusDiv.textContent = 'Error loading data. Check console for details.';
            }
        }

        async function loadCountyBoundaries() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
                const countiesData = await response.json();
                countiesLayer = L.geoJSON(countiesData, {
                    style: { color: "#888", weight: 1, opacity: 0.65, fillOpacity: 0 },
                    interactive: false
                }).addTo(map);
                layersControl.addOverlay(countiesLayer, 'US Counties');
            } catch (error) {
                console.error('Could not load county boundaries:', error);
            }
        }

        // Start
        fetchData();
        setInterval(fetchData, REFRESH_INTERVAL_MS);
        loadCountyBoundaries();
    </script>
</body>
</html>
