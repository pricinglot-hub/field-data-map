<!DOCTYPE html>
<html>
<head>
    <title>Field Data Monitor</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet core -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- MarkerCluster -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        #map { height: 100vh; width: 100%; }

        .info-panel {
            position: absolute; top: 10px; right: 10px; z-index: 1000;
            background: white; padding: 10px 12px; border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.15);
            min-width: 220px;
        }
        .info-panel strong { display: block; margin-bottom: 6px; }
        .stats { font-size: 13px; line-height: 1.5; color: #333; }
        .stats .row { display: flex; justify-content: space-between; }
        .stats .label { color: #666; }
        .stats .value { font-weight: 600; }

        .control-panel {
            position: absolute; top: 10px; left: 10px; z-index: 1000;
            background: white; padding: 10px 12px; border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.15);
            font-size: 13px;
        }
        .control-panel .row { display: flex; gap: 8px; align-items: center; margin-top: 6px; flex-wrap: wrap; }
        .control-panel select, .control-panel input, .control-panel button {
            font-size: 13px; padding: 6px 8px; border-radius: 6px; border: 1px solid #ddd;
        }
        .control-panel button {
            background: #4f46e5; color: white; border: none; cursor: pointer;
        }
        .control-panel button:hover { background: #4338ca; }

        .timeline {
            position: absolute; left: 50%; transform: translateX(-50%);
            bottom: 58px; z-index: 1000; /* above layer control at bottom-right */
            background: white; padding: 10px 12px; border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.15);
            display: flex; gap: 10px; align-items: center;
            min-width: 360px;
        }
        .timeline button {
            background: #4f46e5; color: #fff; border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer;
        }
        .timeline button:hover { background: #4338ca; }
        .timeline input[type="range"] { width: 240px; }
        .timeline .time-label { font-size: 12px; color: #333; min-width: 100px; text-align: right; }

        /* Dot for cluster mode (L.divIcon content) */
        .dot {
            width: 10px; height: 10px; border-radius: 50%;
            box-shadow: 0 0 8px rgba(168, 85, 247, 0.35); /* purple glow */
        }

        /* Purple cluster look */
        .marker-cluster-small, .marker-cluster-medium, .marker-cluster-large {
            background: rgba(168,85,247,0.25);
        }
        .marker-cluster div {
            background: #a855f7; color: #fff; border: 2px solid #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <!-- Mini dashboard -->
    <div class="info-panel">
        <strong>Live Field Map</strong>
        <div id="status">Loading data...</div>
        <div class="stats" style="margin-top:8px;">
            <div class="row"><div class="label">Last hour</div><div class="value" id="countHour">0</div></div>
            <div class="row"><div class="label">Today</div><div class="value" id="countToday">0</div></div>
        </div>
    </div>

    <!-- Filters -->
    <div class="control-panel">
        <div class="row">
            <label for="preset">Date Range:</label>
            <select id="preset">
                <option value="all">All</option>
                <option value="today">Today</option>
                <option value="last2">Last 2 days</option>
                <option value="custom">Custom</option>
            </select>
            <input type="date" id="startDate" disabled />
            <input type="date" id="endDate" disabled />
            <button id="applyRange" disabled>Apply</button>
        </div>
    </div>

    <!-- Time slider -->
    <div class="timeline">
        <button id="playPause">Play</button>
        <input type="range" id="timeSlider" min="0" max="100" value="100" step="1" />
        <div class="time-label" id="timeLabel">--</div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbyZjjPHSKNNGJBJudDzshTc1XASWrMtDALSN5kwNOP7edELrv8eqh_r3hBcdCGgYUrFPQ/exec'; // Paste your URL here
        const REFRESH_INTERVAL_MS = 60000;
        const BASE_PURPLE = '#a855f7'; // tailwind purple-500
        const CLUSTER_UNTIL_ZOOM = 5;  // cluster at low zoom
        const COUNTY_ZOOM_MAX = 6;     // only show county boundaries at US-level
        const HARD_LIMIT = 20000;      // safety: cap how many we render at once
        // --- END CONFIGURATION ---

        // Basemaps (default: Light)
        const plainWhite = L.gridLayer({ attribution: '' });
        plainWhite.createTile = function(coords) {
            const tile = document.createElement('canvas');
            tile.width = 256; tile.height = 256;
            const ctx = tile.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 256, 256);
            return tile;
        };
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap contributors' });
        const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OpenStreetMap, © CARTO' });
        const dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, attribution: '© OpenStreetMap, © CARTO' });
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles © Esri — sources: Esri, USGS, USDA, etc.' });
        const topo = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: '© OpenTopoMap (CC-BY-SA), © OpenStreetMap' });

        const map = L.map('map', {
            center: [40.0, -96.0],
            zoom: 4,
            preferCanvas: true,
            layers: [cartoLight] // default Light (Carto)
        });

        // Basemap control at bottom-right
        const baseMaps = {
            "Light (Carto)": cartoLight,
            "Street (OSM)": osm,
            "Plain White": plainWhite,
            "Dark (Carto)": dark,
            "Satellite (Esri)": satellite,
            "Topo (OpenTopoMap)": topo
        };
        const layersControl = L.control.layers(baseMaps, null, { position: 'bottomright' }).addTo(map);

        // UI elements
        const statusDiv = document.getElementById('status');
        const countHourEl = document.getElementById('countHour');
        const countTodayEl = document.getElementById('countToday');
        const presetSel = document.getElementById('preset');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const applyRangeBtn = document.getElementById('applyRange');
        const timeSlider = document.getElementById('timeSlider');
        const timeLabel = document.getElementById('timeLabel');
        const playPauseBtn = document.getElementById('playPause');

        // Data state
        let allFeatures = [];      // all from server, with tsMs
        let filteredFeatures = []; // after date-range filter
        let currentTimeMs = 0;     // slider time
        let rangeStartMs = 0;      // active date filter start
        let rangeEndMs = 0;        // active date filter end
        let isPlaying = false;

        // Layers
        let dotsLayer = null;            // L.geoJSON (circle markers on Canvas)
        let clusterLayer = null;         // L.MarkerClusterGroup
        let usingCluster = false;        // current render mode
        let countiesLayer = null;        // GeoJSON
        let countiesLoaded = false;

        // Helpers -------------------------------------------------------------

        function toMs(d) { return d instanceof Date ? d.getTime() : Number(d); }
        function startOfTodayMs() { const d = new Date(); d.setHours(0,0,0,0); return d.getTime(); }
        function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

        // Maintain purple hue; vary lightness for recency gradient
        // newer -> deeper purple (lower lightness), older -> lighter purple
        function colorForRecency(ts, minTs, maxTs) {
            const span = Math.max(1, maxTs - minTs);
            const ratio = clamp((ts - minTs) / span, 0, 1); // 0 old -> 1 new
            const hue = 270;      // purple
            const sat = 85;       // %
            const light = 85 - Math.round(40 * ratio); // 85% (old) -> 45% (new)
            return `hsl(${hue} ${sat}% ${light}%)`;
        }

        function parseTimestamp(str) {
            // Prefer ISO. If server returns locale strings, attempt parse; fallback to now.
            const t = Date.parse(str);
            return isNaN(t) ? Date.now() : t;
        }

        function featuresFromServer(data) {
            // Assume data is GeoJSON FeatureCollection; properties.timestamp exists
            const feats = (data.features || []).map(f => {
                const tsMs = f.properties && f.properties.timestamp ? parseTimestamp(f.properties.timestamp) : Date.now();
                // Keep tsMs alongside original feature
                return { ...f, properties: { ...f.properties, _ts: tsMs } };
            });
            // Sort by time ascending
            feats.sort((a,b) => (a.properties._ts - b.properties._ts));
            // Cap to HARD_LIMIT for safety
            return feats.slice(-HARD_LIMIT);
        }

        function updateDashboard(features) {
            const now = Date.now();
            const lastHour = now - 3600 * 1000;
            const todayStart = startOfTodayMs();
            const hourCount = features.filter(f => f.properties._ts >= lastHour).length;
            const todayCount = features.filter(f => f.properties._ts >= todayStart).length;
            countHourEl.textContent = hourCount.toLocaleString();
            countTodayEl.textContent = todayCount.toLocaleString();
        }

        function applyDateFilter() {
            const preset = presetSel.value;
            const now = Date.now();

            if (preset === 'today') {
                rangeStartMs = startOfTodayMs();
                rangeEndMs = now;
            } else if (preset === 'last2') {
                rangeStartMs = now - 2 * 24 * 3600 * 1000;
                rangeEndMs = now;
            } else if (preset === 'custom') {
                const s = startDateInput.value ? new Date(startDateInput.value + 'T00:00:00').getTime() : null;
                const e = endDateInput.value ? new Date(endDateInput.value + 'T23:59:59').getTime() : null;
                rangeStartMs = s ?? (allFeatures[0]?.properties._ts || now);
                rangeEndMs = e ?? (allFeatures[allFeatures.length-1]?.properties._ts || now);
            } else { // 'all'
                rangeStartMs = allFeatures[0]?.properties._ts || now - 24*3600*1000;
                rangeEndMs = allFeatures[allFeatures.length-1]?.properties._ts || now;
            }

            filteredFeatures = allFeatures.filter(f => f.properties._ts >= rangeStartMs && f.properties._ts <= rangeEndMs);
            updateDashboard(filteredFeatures);
            setupTimeSlider();
            renderAtTime(rangeEndMs, { force: true }); // show entire range by default
        }

        function setupTimeSlider() {
            if (!filteredFeatures.length) {
                timeSlider.min = 0; timeSlider.max = 1; timeSlider.value = 1; timeLabel.textContent = '--';
                return;
            }
            const minTs = filteredFeatures[0].properties._ts;
            const maxTs = filteredFeatures[filteredFeatures.length-1].properties._ts;
            // Use timestamps directly to preserve precision; step ~ 1% of span
            const span = Math.max(1, maxTs - minTs);
            const step = Math.max(60000, Math.floor(span / 200)); // at least 1 min; ~200 steps
            timeSlider.min = String(minTs);
            timeSlider.max = String(maxTs);
            timeSlider.step = String(step);
            timeSlider.value = String(maxTs);
            currentTimeMs = maxTs;
            timeLabel.textContent = new Date(currentTimeMs).toLocaleString();
        }

        function buildDotsLayer(visible) {
            if (dotsLayer) { map.removeLayer(dotsLayer); dotsLayer = null; }
            const minTs = rangeStartMs, maxTs = currentTimeMs || rangeEndMs;
            dotsLayer = L.geoJSON({ type: 'FeatureCollection', features: visible }, {
                pointToLayer: (feature, latlng) => {
                    const c = colorForRecency(feature.properties._ts, minTs, maxTs);
                    return L.circleMarker(latlng, {
                        radius: 6,
                        stroke: false,
                        fillColor: c,
                        fillOpacity: 0.9,
                        renderer: L.canvas({ padding: 0.5 })
                    });
                },
                onEachFeature: (feature, layer) => {
                    const ts = new Date(feature.properties._ts).toLocaleString();
                    layer.bindPopup(`<b>Timestamp:</b> ${ts}`);
                }
            }).addTo(map);
        }

        function buildClusterLayer(visible) {
            if (clusterLayer) { map.removeLayer(clusterLayer); clusterLayer = null; }
            clusterLayer = L.markerClusterGroup({
                showCoverageOnHover: false,
                spiderfyOnMaxZoom: true,
                maxClusterRadius: 60,
                disableClusteringAtZoom: CLUSTER_UNTIL_ZOOM + 1,
                iconCreateFunction: (cluster) => {
                    const count = cluster.getChildCount();
                    let size = 'small';
                    if (count >= 100) size = 'large';
                    else if (count >= 20) size = 'medium';
                    return new L.DivIcon({
                        html: `<div><span>${count}</span></div>`,
                        className: 'marker-cluster marker-cluster-' + size,
                        iconSize: new L.Point(40, 40)
                    });
                }
            });

            const minTs = rangeStartMs, maxTs = currentTimeMs || rangeEndMs;
            visible.forEach(f => {
                const [lon, lat] = f.geometry.coordinates;
                const c = colorForRecency(f.properties._ts, minTs, maxTs);
                const icon = L.divIcon({
                    className: '',
                    html: `<div class="dot" style="background:${c};"></div>`,
                    iconSize: [10,10]
                });
                const m = L.marker([lat, lon], { icon });
                const ts = new Date(f.properties._ts).toLocaleString();
                m.bindPopup(`<b>Timestamp:</b> ${ts}`);
                clusterLayer.addLayer(m);
            });

            clusterLayer.addTo(map);
        }

        function setRenderMode(useCluster) {
            usingCluster = useCluster;
        }

        function renderAtTime(tMs, opts = {}) {
            if (!filteredFeatures.length) {
                if (dotsLayer) map.removeLayer(dotsLayer);
                if (clusterLayer) map.removeLayer(clusterLayer);
                statusDiv.textContent = 'No data in selected range.';
                return;
            }

            currentTimeMs = tMs;
            timeLabel.textContent = new Date(currentTimeMs).toLocaleString();

            // Only show points up to current time (for animation)
            const visible = filteredFeatures.filter(f => f.properties._ts <= currentTimeMs);

            const zoom = map.getZoom();
            const shouldCluster = !isPlaying && zoom <= CLUSTER_UNTIL_ZOOM;

            // Only rebuild layers if needed or forced
            if (shouldCluster !== usingCluster || opts.force) {
                // Rebuild fresh in the desired mode
                if (dotsLayer) { map.removeLayer(dotsLayer); dotsLayer = null; }
                if (clusterLayer) { map.removeLayer(clusterLayer); clusterLayer = null; }
                if (shouldCluster) {
                    buildClusterLayer(visible);
                } else {
                    buildDotsLayer(visible);
                }
                setRenderMode(shouldCluster);
            } else {
                // Update existing mode by rebuilding its layer (simple, reliable)
                if (usingCluster) {
                    buildClusterLayer(visible);
                } else {
                    buildDotsLayer(visible);
                }
            }

            statusDiv.textContent = `Updated: ${new Date().toLocaleTimeString()} (${visible.length.toLocaleString()} points)`;
        }

        // Lazy counties -------------------------------------------------------
        async function ensureCountiesLoaded() {
            if (countiesLoaded) return;
            try {
                const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
                const countiesData = await response.json();
                countiesLayer = L.geoJSON(countiesData, {
                    style: { color: "#888", weight: 1, opacity: 0.65, fillOpacity: 0 },
                    interactive: false
                });
                countiesLoaded = true;
            } catch (e) {
                console.error('Could not load county boundaries:', e);
            }
        }

        async function handleCountyVisibility() {
            const z = map.getZoom();
            if (z <= COUNTY_ZOOM_MAX) {
                await ensureCountiesLoaded();
                if (countiesLayer && !map.hasLayer(countiesLayer)) countiesLayer.addTo(map);
            } else {
                if (countiesLayer && map.hasLayer(countiesLayer)) map.removeLayer(countiesLayer);
            }
        }

        // Events --------------------------------------------------------------
        map.on('zoomend', () => {
            handleCountyVisibility();
            // Switch between cluster/dots smartly (no animation)
            renderAtTime(currentTimeMs);
        });

        presetSel.addEventListener('change', () => {
            const isCustom = presetSel.value === 'custom';
            startDateInput.disabled = !isCustom;
            endDateInput.disabled = !isCustom;
            applyRangeBtn.disabled = !isCustom;
            if (!isCustom) applyDateFilter();
        });

        applyRangeBtn.addEventListener('click', () => {
            applyDateFilter();
        });

        timeSlider.addEventListener('input', () => {
            // If user scrubs at low zoom, switch to dots for clarity
            if (map.getZoom() <= CLUSTER_UNTIL_ZOOM) map.setZoom(CLUSTER_UNTIL_ZOOM + 1);
            const val = Number(timeSlider.value);
            renderAtTime(val);
        });

        let playTimer = null;
        function play() {
            if (isPlaying) return;
            isPlaying = true;
            playPauseBtn.textContent = 'Pause';
            // Ensure dots mode for animation
            if (map.getZoom() <= CLUSTER_UNTIL_ZOOM) map.setZoom(CLUSTER_UNTIL_ZOOM + 1);

            const minTs = Number(timeSlider.min);
            const maxTs = Number(timeSlider.max);
            let cur = Number(timeSlider.value);
            const step = Math.max(60000, Math.floor((maxTs - minTs) / 150)); // ~150 frames, at least 1 min per step

            playTimer = setInterval(() => {
                cur += step;
                if (cur >= maxTs) {
                    cur = maxTs;
                    pause();
                }
                timeSlider.value = String(cur);
                renderAtTime(cur);
            }, 150); // ~6-7s for full run; adjust as desired
        }

        function pause() {
            isPlaying = false;
            playPauseBtn.textContent = 'Play';
            if (playTimer) clearInterval(playTimer);
            playTimer = null;
            // After animation, allow smart rendering again (handled on next zoom or render)
        }

        playPauseBtn.addEventListener('click', () => {
            if (isPlaying) pause(); else play();
        });

        // Data fetch ----------------------------------------------------------
        async function fetchData() {
            try {
                statusDiv.textContent = 'Fetching new data...';
                const url = `${WEB_APP_URL}?t=${Date.now()}`; // cache-buster
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();

                const feats = featuresFromServer(data);
                allFeatures = feats;
                // If first load, fit bounds
                if (allFeatures.length) {
                    const coords = allFeatures.map(f => [f.geometry.coordinates[1], f.geometry.coordinates[0]]);
                    const bounds = L.latLngBounds(coords);
                    if (bounds.isValid()) map.fitBounds(bounds.pad(0.1));
                }

                applyDateFilter(); // sets filteredFeatures, dashboard, slider, and renders
            } catch (error) {
                console.error('Failed to fetch map data:', error);
                statusDiv.textContent = 'Error loading data.';
            }
        }

        // Start
        fetchData();
        setInterval(fetchData, REFRESH_INTERVAL_MS);
        handleCountyVisibility(); // initial
    </script>
</body>
</html>
